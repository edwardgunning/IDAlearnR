---
title: "Introduction to the `tidyverse`"
output:
  learnr::tutorial:
          progressive: true
          allow_skip: true
          highlight: pygments
          ace_theme: textmate
runtime: shiny_prerendered
---


<!-- insert UL logo in top right corner -->
<div style="text-align: right"><img src="images/ul-logo.jpg" width="150" /></div>


<!-- include CSS within markdown document -->
<!-- not sure why linking to the CSS doesn't work-->
```{css, echo = F}
@import url(https://fonts.googleapis.com/css?family=Montserrat:300,300i&display=swap);
@import url(https://fonts.googleapis.com/css?family=Josefin+Sans&display=swap);
@import url(https://fonts.googleapis.com/css?family=Fira+Mono&display=swap);
@import url(https://fonts.googleapis.com/css?family=Intero&display=swap);
@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed&display=swap);

:root {
  /* Fonts */
  --text-font-family: 'Inter';
  --text-font-is-google: 1;
  --text-font-family-fallback: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial;
  --text-font-base: sans-serif;
  --header-font-family: 'Josefin Sans';
  --header-font-is-google: 1;
  --code-font-family: 'Fira Mono';
  --code-font-is-google: 1;
  --base-font-size: 15px;
  --text-font-size: 1rem;
  --code-font-size: 0.9rem;
  --code-inline-font-size: 0.9rem;
  --header-h1-font-size: 2.75rem;
  --header-h2-font-size: 2.25rem;
  --header-h3-font-size: 1.75rem;

  /* Colors */
  --text-color: #272822;
  --header-color: #005337;
  --background-color: #FFFFFF;
  --link-color: #0fb157;
  --text-bold-color: #0fb157;
  --code-highlight-color: rgba(255,255,0,0.5);
  --inverse-text-color: #FFFFFF;
  --inverse-background-color: #005337;
  --inverse-header-color: #FFFFFF;
  --title-slide-background-color: #1c5253;
  --title-slide-text-color: #FFFFFF;
  --header-background-color: #1c5253;
  --header-background-text-color: #FFFFFF;
  --base: #1c5253;
  --white: #FFFFFF;
  --black: #272822;
}



code {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

code.r {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

pre {
  font-size: 14px;
}

h1, #TOC>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
  text-align: center;
}

h2, #TOC>ul>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h3 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h4 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

a {
  color: #0ead5b;
}


body {
  font-family: var(--text-font-family), var(--text-font-family-fallback), var(--text-font-base);
  font-weight: 500;
  color: var(--text-color);
  font-size: 16px
}


a, a > code {
  color: #272822;
  text-decoration: underline;
  font-size: 16px;
}


.notesbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/notes.png)
}

.tipsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/lightbulb.png)
}

.readingbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/open-book.png)
}

.videobox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/video.png)
}

.hintsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #B0C4DE;
  border-radius: 10px;
  background: #F0F8FF 5px center/3em no-repeat;
  background-image: url(images/whisper.png)
}

.extrabox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #D8BFD8;
  border-radius: 10px;
  background: #FFF0F5 5px center/3em no-repeat;
  background-image: url(images/extra.png)
}


.exercise-box {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px double #E8E8E8;
  border-radius: 10px;
  background: #F8F8FF 5px center/3em no-repeat;
}


.center {
  text-align: center;
}
```


<!-- Got below tip for editor font size from https://github.com/rstudio/learnr/issues/197-->

```{js, echo = FALSE}
$(function() {
   var editor;
   $('.ace_editor').each(function( index ) {
     editor = ace.edit(this);
     editor.setFontSize("14px");
   });
})
```

<!-- <head> -->
<!-- <link rel="stylesheet" type="text/css" href="css/minty_bootstrap.css"> -->
<!-- </head> -->


```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(nycflights13)

knitr::opts_chunk$set(echo = FALSE)

data("flights", package = "nycflights13")
credit_df <- read_csv('./data/UCI_Credit_Card_2.csv', n_max = 10)
#flights <- read_csv('./data/flights.csv')


p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

##

> “The Tidyverse has revolutionized the way in which data scientists do almost every aspect of their job.”
>
> Wright, Ellis, Hicks and Peng (2021)

## What is the tidyverse?

### 

- The [`tidyverse`](https://www.tidyverse.org/) is a coherent suite of R packages designed for *data import*, *manipulation*, *exploration* and *visualisation*.

- The tidyverse is a “package of packages” - when we load the tidyverse package, we load ("attach") multiple packages:

```{r, eval=FALSE, echo=TRUE}
> library(tidyverse)
-- Attaching packages --------------------------------------- tidyverse 1.2.1 --
v ggplot2 3.2.1     v purrr   0.3.2
v tibble  2.1.3     v dplyr   0.8.3
v tidyr   0.8.3     v stringr 1.4.0
v readr   1.3.1     v forcats 0.4.0
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x dplyr::filter() masks stats::filter()
x dplyr::lag()    masks stats::lag()
```

- All packages share an underlying design philosophy, grammar, and data structures… they are designed to work with **"tidy data"**.

### Tidy data

> “Tidy datasets are easy to manipulate, model and visualise, and have a specific structure:
each variable is a column, each observation is a row, and each type of observational unit
is a table.”
>
> Wickham (2014)

In short, tidy data are rectangular data, obeying the following interrelated rules (Fig. 1):

1.	Each variable must have its own column.

2.	Each observation must have its own row.

3.	Each value must have its own cell.

---

```{r, fig.cap="**Fig 1:** Graphical illustration of tidy data, taken from [R for Data Science](https://r4ds.had.co.nz/tidy-data.html?q=tidy%20data#non-tidy-data)", out.width='90%'}
knitr::include_graphics(path = "images/tidy-data-pic.png")
```

---

### tibbles

Tidy data provides an _consistent_ underlying data structure on which the tidyverse tools are built. You will also notice that, by default, the tidyverse uses __tibbles__, rather than __data frames__.

Tibbles are essentially data frames (as covered in the previous sections) but with some minor changes designed to improve functionality. 

Tibbles have slight modifications to help avoid programming errors, and have an enhanced method for bring printed to the screen.

:::: {.exercise-box }

#### Exercise

Create a tibble containing the variables `x = c("a", "b", "c")` and `y = c(1, 2, 3)` using the `tibble()` function. Print it to the screen.

:::: {.hintsbox }
**Hint:** Use the `tibble()` function in the exact same way you have used the `data.frame()` function in previous sections.
::::

```{r tibbledf, exercise = TRUE, exercise.lines = 7}

```

```{r tibbledf-solution}
tbl <- tibble(x = c("a", "b", "c"),
                 y = c(1, 2, 3))

tbl
```

::::

:::: {.readingbox }
The best place to read more about tibbles is [Chapter 10 of R for Data Science](https://r4ds.had.co.nz/tibbles.html#tibbles).
::::

From now on, we will use tibbles and data frames interchangeably.

<!-- ### Other useful packages -->

<!-- The following are some useful packages that are, at the time of writing, not included in the `tidyverse` but are very useful. -->

<!-- - `dbplyr`: for use with databases. -->
<!-- - `multiplyr`: for parallel processing. -->
<!-- - `plyr`: old package but has some handy functions in it. -->
<!-- - `tsibble`: makes dealing with and modeling timeseries data easier.  -->

## The pipe operator

###

The pipe operator is a powerful tool for clearly expressing a sequence of multiple R function operations.

Say we wish to first take the absolute value of the the sequence of integers from -5 to 5, then sum these absolute values up, and then take the log of this sum.

```{r,  echo=TRUE}
x <- seq(from = -5, to = 5, by = 1)
```

Given what we have learned so far, we would do the following.

```{r, echo=TRUE}
log(sum(abs(x))) # ugly looking
```

###

However, these nested function calls are not a natural way to think about the operations, and the syntax can become messy when there are many operations.

The pipe operator allows us to chain these operations together in a logical fashion. It "pipes" what is on the left-hand side of the `%>%` operator into the first argument of the function on the right-hand side.

```{r, echo=TRUE}
x %>% # better looking
  abs() %>% 
  sum() %>% 
  log() 
```

### Interpreting the pipe

> “Whenever you see the pipe `%>%`, think of the word 'then'...”
>
> Wright, Ellis, Hicks and Peng (2021)

For example, we should read the previous piece of code as:

```{r,  eval=FALSE, echo=TRUE}
x %>% # get x then
  abs() %>% # take the absolute values then
  sum() %>% # sum them up then
  log() # take the log
```

###

:::: {.exercise-box }
#### Exercise

In statistics and machine learning, the mean-absolute error (MAE) is a measure of the difference between values predicted by a model and observed values in the data. 

Given a vector of errors (typically known as residuals or prediction errors), the MAE is calculated by:

1. Taking the absolute values of the errors

2. Taking the average of the absolute values

Combine the `%>%` operator with the `mean()` and `sqrt()` and `round()` functions to calculate the MAE from the following vectors of observations and predictions, rounded to the nearest whole number.

The answer should be 8.

```{r rmse, exercise = TRUE, exercise.lines = 10}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)
```

```{r rmse-solution}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)

(observations - predictions) %>% # get errors, then
  abs() %>% # take absolute values, then
  mean() %>% # take mean, then
  round() # round to the nearest whole number
```

::::

<!-- ### When **not** to use the pipe -->

<!-- The tidyverse functions are all designed to work consistently with the pipe operator, as they typically take data frames/ tibbles as their first argument, and return data frames/ tibbles. -->

<!-- However, we should avoid using the pipe when: -->

<!-- - You need to manipulate more than one object at a time. Reserve pipes for a sequence of steps applied to one primary data object. -->
<!-- - There are meaningful intermediate objects that could be given informative names. -->

## Basics of dplyr

### What is dplyr?

:::: {style="display: flex;"}

::: {}
<br>

> dplyr is a tidyverse package that implements a "grammar of data manipulation". It provides a consistent set of verbs that help you solve the most common data manipulation challenges.
> 

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/dplyr.png")
```
:::

::::


### The dplyr verbs

The vast majority of data manipulation tasks can be solved using just five dplyr functions. They are all named after a *verb* which describes the task.

- Pick observations (rows) based on their values (`filter()`).
- Reorder the rows (`arrange()`). 
- Pick variables (columns) based on their names (`select()`).
- Create new variables by transforming existing variables (`mutate()`).
- Collapse multiple values down to a single summary (`summarise()`).

:::: {.extrabox }
The `group_by()` function allows the above operations to be split by a particular categorical/grouping variable. 
::::

<!-- You will notice that in this section we deal with __tibbles__ instead of __data frames__. A tibble is just a data frame with a better display format. Also, tibbles and data frames can return different objects. For example, extracting column from a data frame (via `example_data_frame[, 1]`) return a vector of differing data types, for a tibble on the other, subsetting a tibble my its column will always return a tibble. This make tibbles behaviour when coding more robust.  -->

We will examine each function in the following sections.

### 

All dplyr functions work similarly: 

1.  The first argument is the tibble (or data frame).
1.  The subsequent arguments describe what to do with the tibble, using the variable names (without quotes). 
1.  The result is a new tibble (or data frame).


### Data set

<!-- ```{r setup2, message = FALSE} -->
<!-- library(nycflights13) -->
<!-- data("flights", package = "nycflights13") -->
<!-- library(tidyverse) -->
<!-- ``` -->

To explore the basic data manipulation verbs of dplyr, we'll use `nycflights13::flights`. This tibble contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013. The data comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0). We have loaded the `nycflights13` package in the background so that you can access the dataset with the `flights` command and the documentation with `?flights`. 

:::: {.exercise-box }

#### Exercise

Use the `head()` or `str()` functions to explore `flights` dataset.

```{r dplyr-1, exercise=TRUE, exercise.lines = 5}
flights
```

```{r, dplyr-1-solution}
head(flights)
str(flights)
```

::::

:::: {.notesbox }
Note that the variables `year`, `month` and `day`, are all integers. 
::::

## Filter rows with filter()

###

> `filter()` is used to subset rows using column values. 

The first argument is the data, and subsequent arguments are logical statements (called conditions) about the columns, using just the column names (without quotation marks or `$` operators). To be retained, the row must produce a value of `TRUE` for all conditions.


### 

The general form is:

```{r, eval = FALSE, echo = TRUE}
filter(data, condition_1, condition_2, condition_3)
```

Or, using the pipe:

```{r, eval = FALSE, echo = TRUE}
data %>% filter(condition_1, condition_2, condition_3)
```

:::: {.notesbox }
When we are piping data into dplyr functions, we can omit the first argument as dplyr assumes this to be the piped quantity.
::::

###

For example, we can use `filter()` to select all flights on January 1st with:

```{r, echo = TRUE}
filter(flights, month == 1, day == 1)
```

<!-- ```{r, echo = TRUE} -->
<!-- flights %>% filter(month == 1, day == 1) -->
<!-- ``` -->

### 

This is equivalent to the base R notation of `month == 1 & day == 1`. If we wanted to redo the previous example using base `R` we would have to use the following, less readable section of code. 

```{r, echo = TRUE}
flights[flights$month == 1 & flights$day == 1, ]
```

:::: {.notesbox }
**Note:** In contrast to base R, the dplyr syntax allows us call columns by their name (without the `$` operator), and allows us to separate `&` statements with a comma.
::::

###

:::: {.exercise-box }
#### Exercise

Filter all flights which departed in November *or* December:

```{r filter-2, exercise=TRUE}

```

```{r filter-2-solution}
filter(flights, month == 11 | month == 12)
# or, with the pipe
flights %>% filter(month == 11 | month == 12)
```

::::

###

:::: {.tipsbox }

**Tip:** An alternative form for selecting the months November or December would be `month %in% c(11, 12)`. This is very useful for selecting multiple months such as `month %in% c(11, 12, 1)`, which is nicer than using the OR notation `month == 11 | month == 12 | month == 1`.

```{r echo = TRUE, eval = FALSE}
filter(flights, month %in% c(12, 11, 1))
```

:::: 



## Arrange rows with arrange()

###

> `arrange()` orders the rows of a data frame by the values of selected columns.

### 

For example, to order the `flights` dataset by year, month and day:

```{r, echo = TRUE}
arrange(flights, year, month, day)
```

### 

By default, `arrange()` sorts in ascending order, but descending order can be achieved using `desc()`, for example:

```{r, echo = TRUE}
flights %>% arrange(desc(dep_delay))
```

### 

:::: {.exercise-box }
#### Exercise

The `distance` column of the `flights` dataset contains the distance between airports, in miles. Arrange the rows of the dataset based on the distance of the flights, from longest to shortest.

```{r, arrange-1, exercise = TRUE, exercise.lines = 6}

```

```{r, arrange-1-solution}
flights %>% arrange(desc(distance))
```
::::

## Select columns with select()

###

> `select()` allows you to select variables in your dataset to be retained or removed.

It is very useful for very large datasets which may contain many unnecessary variables.

###

For example if we wanted to select only the variables year, month, and day. 

```{r, echo = TRUE}
# Select columns by name
flights %>% select(year, month, day)
```

###

:::: {.exercise-box }

#### Exercise

Select only the `origin`, `dest` and `air_time` columns from the `flights` dataset. Store the result, and print the first few rows using `head()`.

```{r select-ex, exercise = TRUE, exercise.lines = 5}

```

```{r select-ex-solution}
flights_subset <- flights %>% select(origin, dest, air_time)
head(flights_subset)
```

::::

### Short cuts with select

There are several short cuts available for subsetting - they provide quick ways to specify a subset of columns. For example, You can use `:` to select all columns that are between two columns.

```{r select-2, echo = TRUE}
# Select all columns between year and day (inclusive)
flights %>% select(year:day)
```

###

Prefixing any (set of) column name(s) with a `-` or `!` removes them. 

```{r select-3, echo = TRUE}
# Select all columns except those from year to day (inclusive)
flights %>% select(-(year:day))
```

###

If you want to reorder columns, using `select()` with the `everything()` function is useful.

```{r select-4, echo = TRUE}
# Select time_hour, air_time and then every other column:
flights %>% select(time_hour, air_time, everything()) 
```

###

:::: {.exercise-box }
####  Exercise

Use the `select()` function to select all columns except those from `dep_time` to `tailnum` (inclusive), and re-order the resulting columns to start with `origin` and `dest`.

:::: {.hintsbox }
**Hint:** Use the pipe operator to apply the select function twice.
::::

```{r selectx2, exercise = TRUE, exercise.lines = 6}

```

```{r, selectx2-solution}
flights %>%
  select(-(dep_time:tailnum)) %>%
  select(origin, dest, everything())
```

::::

###

:::: {.readingbox }
There are several other helper functions for subsetting columns with `select()`:

- `starts_with()` 
- `ends_with()`
- `contains()`
- `matches()`
- `num_range()`
- `one_of()`
- `everything()`
- `group_cols()`

Read [this documentation](https://dplyr.tidyverse.org/reference/select.html) on the dplyr website to learn more.
::::

## Add new variables with mutate()

###

> `mutate()` adds new variables that are functions of existing variables

It is often useful to create new variables which are transformations of one or more existing variables.

###

For example, the `air_time` variable is measured in minutes, and we might wish to have it in hours.

```{r, echo = TRUE}
flights %>%
  mutate(air_time_hr = air_time / 60) %>% # divide air_time by 60 to give in hours
  select(air_time, air_time_hr, everything())
```

###

We can create multiple new variables in a single `mutate()` call by separating them with a comma. Newly created variables are available immediately in the same `mutate()` call.

```{r, echo = TRUE}
flights %>% mutate(air_time_hr = air_time / 60, # what was the air time in hours? 
       gain = dep_delay - arr_delay, # add variable for how late the flight was
       gain_per_hour = gain / air_time_hr)
```

###

:::: {.exercise-box }
#### Exercise

Create a new variable, called `route`, which combines the `origin` and `dest` variables, separated by an underscore (`_`). 

:::: {.hintsbox }
**Hint:** The `paste()` function can be used to combine two strings. The `sep =` argument can be used to specify the string to separate them.
::::

```{r routemutate, exercise = TRUE, exercise.lines = 8}

```

```{r routemutate-solution}
flights %>%
  mutate(route = paste(origin, dest, sep = "_")) %>%
  select(route, everything()) # re-order columns to see route first
```

::::



###

:::: {.exercise-box }
#### Exercise

Create a new variable, called `av_speed`, which gives the average speed of the flight in miles per hour.  Re-order the rows from fastest to slowest.

:::: {.hintsbox }
**Hint:** First an `air_time_hr` variable giving air time in hours, and then combine this with `distance` to get the average speed in miles per hour.
::::

```{r speed-mutate, exercise = TRUE, exercise.lines = 8}

```

```{r speed-mutate-solution}
flights %>%
  mutate(air_time_hr = air_time / 60, # first calculate air time in hours
         av_speed = distance / air_time_hr) %>% # average speed = distance / time
  arrange(desc(av_speed)) %>% # arrange by average speed (descending = fastest first)
  select(av_speed, everything())
```
::::


## Create summaries with summarise()

###

> `summarise()` reduces multiple values down to a single summary.

### 
The`summarise()` function  collapses a tibble or data frame to a single row:

```{r summarise-1, echo = TRUE}
summarise(flights, mean_dep_delay = mean(dep_delay, na.rm = TRUE))
```



After the data, each argument passed to `summarise()` is a summary statistic of one or more existing variables. The summary can be named (e.g., `mean_dep_delay =`) and multiple summaries can be separated by a comma.

###

:::: {.exercise-box }
#### Exercise

Calculate the minimum, maximum and median of the `dep_delay` variable.

```{r summary-delay, exercise = TRUE, exercise.lines = 8}

```

```{r summary-delay-solution}
flights %>% summarise(min_dep_delay = min(dep_delay, na.rm = TRUE),
                      max_dep_delay = max(dep_delay, na.rm = TRUE),
                      med_dep_delay = median(dep_delay, na.rm = TRUE))
```

::::

###  Grouped summaries using group_by()

On its own, `summarise()` may not provide much information. Often it is combined with `group_by()`.

The `group_by()` function changes the _scope_ of the tibble (or data frame) so instead of applying `summarise()` to the whole tibble (or data frame), it calculates the summaries separately for each of the unique groups created by `group_by()`. 

###

For example, if we wanted to generate a table of the `mean` and `median` delay time for every month, we would do the following:

```{r summarise-3, echo = TRUE}
flights %>% 
  group_by(year, month) %>% 
  summarise(
    median_delay = median(dep_delay, na.rm = TRUE),
    mean_delay = mean(dep_delay, na.rm = TRUE)
  )
```

###

:::: {.exercise-box }
#### Exercise

Calculate the mean and median `air_time` for each route (combination of `origin` and `dest`).

```{r summary-route, exercise = TRUE, exercise.lines = 8}

```

```{r summary-route-solution}
flights %>%
  group_by(origin, dest) %>% # group by route
  summarise(mean_air_time = mean(air_time, na.rm = TRUE),
            median_air_time = median(air_time, na.rm = TRUE))
```

::::

###

:::: {.readingbox }
**Note:** When we group by multiple variables and then use `summarise()`, the resulting tibble (or data frame) is grouped by one less variable... each summary "peels off" one level of the grouping. See the example in [R for Data Science](https://r4ds.had.co.nz/transform.html?q=ungroup#grouping-by-multiple-variables).
:::: 

:::: {.readingbox }
**Note:** If you need to return to performing operations on ungrouped data, use `ungroup()`. See the example in [R for Data Science](https://r4ds.had.co.nz/transform.html?q=ungroup#ungrouping).
:::: 

<!-- Together `group_by()` and `summarise()` provide a very quick way to produce summary tables. The returned tibble still has its _scope_ limited to the grouping variables. This can often cause a problem later on in the analysis if you want manipulation to be performed on the whole tibble. The `ungroup()` function returns the _scope_ to the full tibble. For example, we can scale the `mean_delay` from the previous code example using by max mean_deplay before and after using the `ungroup` function to change the scope back to the full dataset. -->

<!-- ```{r summarise-4, exercise = TRUE} -->
<!-- flights %>%  -->
<!--   group_by(year, month, day) %>%  -->
<!--   summarise( -->
<!--     mean_delay = mean(dep_delay, na.rm = TRUE) -->
<!--     ) %>%  -->
<!--   # max mean_delay is applied to the scope of the grouping varaibles -->
<!--   mutate(scaled_mean_delay_1 = mean_delay/max(mean_delay)) %>%  -->
<!--   ungroup() %>%  -->
<!--   # max mean_delay is applied to over the full dataset -->
<!--   mutate(scaled_mean_delay_2 = mean_delay/max(mean_delay)) -->
<!-- ``` -->

## Basics of ggplot2

###

:::: {style="display: flex;"}

::: {}
<br>

> ggplot2 is a system for declaratively creating graphics, based on The Grammar of Graphics.
> 

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/ggplot2.png")
```
:::

::::

###

The base R plotting system that we learned in the first tutorial is quick and easy but offers limited flexibility. In contrast, the `ggplot2` package provides a suite of functions that allow for elegant and detailed statistical graphics to be built *iteratively*, using a "layered approach". Rather than just a series of R commands, `ggplot2` implements a "graphical language".

### The mpg datsset

Let's use our first `ggplot2` graph to answer a question: *Do cars with big engines use more fuel than cars with small engines?* You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

`mpg` contains observations collected by the US Environmental Protection Agency on 234 different cars

```{r plotting-1, echo = TRUE}
mpg <- mpg %>% as_tibble() # the mpg dataset is a data frame. We convert it to a tibble.

mpg %>% head(3)
```

###

Among the variables in `mpg` are:

1. `displ`, a car's engine size, in litres.

1. `hwy`, a car's fuel efficiency on the highway, in miles per gallon (mpg). 
  A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. 

:::: {.extrabox }
To learn more about the `mpg` datset, open its help page by running `?mpg`.
::::

### Creating your first ggplot

The following code creates a scatter plot of `displ` on the x-axis and `hwy` on the y-axis:

```{r plotting-2, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

###

What do these commands mean?

- `ggplot()` creates a coordinate system to which you can add layers.
- The first argument of `ggplot()` is the dataset to be used in the visualization.
- So `ggplot(data = mpg)` creates an empty figure, which is not useful on its own, so I'm not going to show it here.
- `geom_point()` adds a layer of points to your plot. 
- ggplot2 comes with many `geom_` functions that each add a different type of layer to a plot.

You can save a graph object and add layers to it. For example, the code below adds a smoother to the scatter plot.

```{r plotting-3, exercise=TRUE}
p + geom_smooth()
```

- The plot shows a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`).

- Each geom function in ggplot2 takes a `mapping` argument.
- This defines how variables in your dataset are mapped to visual properties.
- The `mapping` argument is always paired with `aes()`, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes.
<!-- - ggplot2 looks for the mapped variables in the `data` argument, in this case, `mpg`. -->

<!-- Add a layer of points over the previous: -->

<!-- ```{r, eval=TRUE, echo=FALSE,  fig.height = 3, fig.width = 4.5, fig.align = "center"} -->
<!-- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + -->
<!--   geom_point() +  -->
<!--   geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), colour = "red", size = 2.2) -->
<!-- ``` -->

What if we wanted to see different classes of cars? We can use the `aes()` function to map the type of cars to different colors. Additionally, we can add a layer to highlight values outside the general trend.

```{r plotting-4, exercise=TRUE}
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point()

```

```{r plotting-4-solution}
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point()

p + 
  geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), 
             colour = "black", size = 4, shape = 1)

```

What if we want to see the different classes of cars? 

```{r plotting-5, exercise=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

What about the distributions? Its easy to plot distributions using the correct `geom_` argument:

- `geom_histogram` 
- `geom_boxplot` 

```{r plotting-6, exercise=TRUE}
ggplot(data = mpg) + 
  geom_histogram(mapping = aes(x = hwy))
```

```{r plotting-7, exercise=TRUE}
ggplot(data = mpg) + 
  geom_boxplot(mapping = aes(x = class, y = hwy, fill = class)) + 
  theme(axis.text.x = element_text(angle = 90))
```

If you want to get fancy you can even layer different distributional visualizations. 

```{r plotting-8, exercise=TRUE}
ggplot(data = mpg) + 
  geom_violin(aes(x = class, y = hwy), fill = 'steelblue') + 
  geom_boxplot(aes(x = class, y = hwy, fill = class), width = 0.1) + 
  theme(axis.text.x = element_text(angle = 90))
```

## Reading in data with and readr

###

:::: {style="display: flex;"}

::: {}
<br>

> The goal of `readr` is to provide a fast and friendly way to read rectangular data. Most of readr’s functions are concerned with turning flat files into data frames.

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/readr.png")
```
:::

::::

###

We have learned some of the basics of manipulating and visualizing data using in-built R datasets. This section shows you how to load in your own external datasets.

### Getting started:
* `read_csv()` reads comma delimited files.
* `read_tsv()` reads tab delimited files.
* `read_delim()` reads in files with any delimiter.
* `read_table()` reads a common variation of fixed width files where columns are separated by white space.

Why use `readr`'s `read_csv()` over in-build `read.csv()`?

- Typically faster.
- Provides information on the variables which have been read in.
- Returns a `tibble` instead of a `data.frame`.

```{r, echo=TRUE, eval = FALSE}
credit_df <- read_csv(file = "./data/credit_data.csv")
```

- Tibbles provide extra information: 

```{r,echo=TRUE, eval = TRUE}
credit_df
```

<!-- `read_csv` parameters: -->

<!-- ```{r, echo = TRUE, eval = TRUE} -->
<!-- parms <- read_csv %>% args() %>% as.list() %>% names() -->
<!-- knitr::kable(tibble(Parameters = parms[c(1,2,3,8,10)])) -->
<!-- ``` -->

<!-- - Remember R has extensive help on every function: -->
<!--   - Highlight the function and press `F1` -->
<!--   - Or run `?function_of_interest`. -->

<!-- ```{r reading-1, exercise=TRUE} -->
<!-- ?read_csv -->
<!-- ``` -->
