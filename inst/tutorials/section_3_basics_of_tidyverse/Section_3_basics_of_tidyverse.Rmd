---
title: "Introduction to the `tidyverse`"
output:
  learnr::tutorial:
          progressive: true
          allow_skip: true
          highlight: pygments
          ace_theme: textmate
runtime: shiny_prerendered
---


<!-- insert UL logo in top right corner -->
<div style="text-align: right"><img src="images/ul-logo.jpg" width="150" /></div>


<!-- include CSS within markdown document -->
<!-- not sure why linking to the CSS doesn't work-->
```{css, echo = F}
@import url(https://fonts.googleapis.com/css?family=Montserrat:300,300i&display=swap);
@import url(https://fonts.googleapis.com/css?family=Josefin+Sans&display=swap);
@import url(https://fonts.googleapis.com/css?family=Fira+Mono&display=swap);
@import url(https://fonts.googleapis.com/css?family=Intero&display=swap);
@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed&display=swap);

:root {
  /* Fonts */
  --text-font-family: 'Inter';
  --text-font-is-google: 1;
  --text-font-family-fallback: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial;
  --text-font-base: sans-serif;
  --header-font-family: 'Josefin Sans';
  --header-font-is-google: 1;
  --code-font-family: 'Fira Mono';
  --code-font-is-google: 1;
  --base-font-size: 15px;
  --text-font-size: 1rem;
  --code-font-size: 0.9rem;
  --code-inline-font-size: 0.9rem;
  --header-h1-font-size: 2.75rem;
  --header-h2-font-size: 2.25rem;
  --header-h3-font-size: 1.75rem;

  /* Colors */
  --text-color: #272822;
  --header-color: #005337;
  --background-color: #FFFFFF;
  --link-color: #0fb157;
  --text-bold-color: #0fb157;
  --code-highlight-color: rgba(255,255,0,0.5);
  --inverse-text-color: #FFFFFF;
  --inverse-background-color: #005337;
  --inverse-header-color: #FFFFFF;
  --title-slide-background-color: #1c5253;
  --title-slide-text-color: #FFFFFF;
  --header-background-color: #1c5253;
  --header-background-text-color: #FFFFFF;
  --base: #1c5253;
  --white: #FFFFFF;
  --black: #272822;
}



code {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

code.r {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

pre {
  font-size: 14px;
}

h1, #TOC>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
  text-align: center;
}

h2, #TOC>ul>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h3 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h4 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

a {
  color: #0ead5b;
}


body {
  font-family: var(--text-font-family), var(--text-font-family-fallback), var(--text-font-base);
  font-weight: 500;
  color: var(--text-color);
  font-size: 16px
}


a, a > code {
  color: #272822;
  text-decoration: underline;
  font-size: 16px;
}


.notesbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/notes.png)
}

.tipsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/lightbulb.png)
}

.readingbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/open-book.png)
}

.videobox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/video.png)
}

.hintsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #B0C4DE;
  border-radius: 10px;
  background: #F0F8FF 5px center/3em no-repeat;
  background-image: url(images/whisper.png)
}

.extrabox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #D8BFD8;
  border-radius: 10px;
  background: #FFF0F5 5px center/3em no-repeat;
  background-image: url(images/extra.png)
}


.exercise-box {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px double #E8E8E8;
  border-radius: 10px;
  background: #F8F8FF 5px center/3em no-repeat;
}


.center {
  text-align: center;
}
```


<!-- Got below tip for editor font size from https://github.com/rstudio/learnr/issues/197-->

```{js, echo = FALSE}
$(function() {
   var editor;
   $('.ace_editor').each(function( index ) {
     editor = ace.edit(this);
     editor.setFontSize("14px");
   });
})
```

<!-- <head> -->
<!-- <link rel="stylesheet" type="text/css" href="css/minty_bootstrap.css"> -->
<!-- </head> -->


```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
# library(nycflights13)

knitr::opts_chunk$set(echo = FALSE)

# data("flights", package = "nycflights13")
# credit_df <- read_csv('./data/UCI_Credit_Card_2.csv', n_max = 10)
# flights <- read_csv('./data/flights.csv')

# p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
#   geom_point()

# set.seed(1)
# small_flights <- nycflights13::flights[sample(seq_len(nrow(nycflights13::flights)), size = 5000, replace = FALSE), ]
# saveRDS(object =  small_flights,
#         file = here::here("inst", "tutorials", "section_3_basics_of_tidyverse", "data", "small_flights.rds"))
flights <- readRDS("data/small_flights.rds")
```

##

> “The Tidyverse has revolutionized the way in which data scientists do almost every aspect of their job.”
>
> Wright, Ellis, Hicks and Peng (2021)

## What is the tidyverse?

### 

- The [`tidyverse`](https://www.tidyverse.org/) is a coherent suite of R packages designed for *data import*, *manipulation*, *exploration* and *visualisation*.

- The tidyverse is a “package of packages” - when we load the tidyverse package, we load ("attach") multiple packages:

```{r, eval=FALSE, echo=TRUE}
> library(tidyverse)
-- Attaching packages --------------------------------------- tidyverse 1.2.1 --
v ggplot2 3.2.1     v purrr   0.3.2
v tibble  2.1.3     v dplyr   0.8.3
v tidyr   0.8.3     v stringr 1.4.0
v readr   1.3.1     v forcats 0.4.0
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x dplyr::filter() masks stats::filter()
x dplyr::lag()    masks stats::lag()
```

- All packages share an underlying design philosophy, grammar, and data structures… they are designed to work with **"tidy data"**.

### Tidy data

> “Tidy datasets are easy to manipulate, model and visualise, and have a specific structure:
each variable is a column, each observation is a row, and each type of observational unit
is a table.”
>
> Wickham (2014)

In short, tidy data are rectangular data, obeying the following interrelated rules (Fig. 1):

1.	Each variable must have its own column.

2.	Each observation must have its own row.

3.	Each value must have its own cell.

---

```{r, fig.cap="**Fig 1:** Graphical illustration of tidy data, taken from [R for Data Science](https://r4ds.had.co.nz/tidy-data.html?q=tidy%20data#non-tidy-data)", out.width='90%'}
knitr::include_graphics(path = "images/tidy-data-pic.png")
```

---

### tibbles

The notion of tidy data provides a _consistent_ underlying structure on which the tidyverse tools are built. You will also notice that, by default, the tidyverse uses __tibbles__, rather than __data frames__.

Tibbles are essentially data frames (as covered in the previous sections) but with some minor changes designed to improve functionality. 

Tibbles have slight modifications to help avoid programming errors, and have an enhanced method for bring printed to the screen.

:::: {.exercise-box }

#### Exercise

Create a tibble containing the variables `x = c("a", "b", "c")` and `y = c(1, 2, 3)` using the `tibble()` function. Call it `my_tbl`. Print it to the screen.

:::: {.hintsbox }
**Hint:** Use the `tibble()` function in the exact same way you have used the `data.frame()` function in previous sections.
::::

```{r tibbledf, exercise = TRUE, exercise.lines = 7}

```

```{r tibbledf-solution}
my_tbl <- tibble(x = c("a", "b", "c"),
                 y = c(1, 2, 3))

my_tbl
```

::::

:::: {.readingbox }
The best place to read more about tibbles is [Chapter 10 of R for Data Science](https://r4ds.had.co.nz/tibbles.html#tibbles).
::::

From now on, we will use tibbles and data frames interchangeably.

<!-- ### Other useful packages -->

<!-- The following are some useful packages that are, at the time of writing, not included in the `tidyverse` but are very useful. -->

<!-- - `dbplyr`: for use with databases. -->
<!-- - `multiplyr`: for parallel processing. -->
<!-- - `plyr`: old package but has some handy functions in it. -->
<!-- - `tsibble`: makes dealing with and modeling timeseries data easier.  -->

## The pipe operator

### 
:::: {style="display: flex;"}

::: {}
<br>

> The pipe operator (`%>%`) is a powerful tool for clearly expressing a sequence of multiple R function operations.


:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/pipe.png")
```
:::

::::


###

Say we wish to first take the absolute value of the the sequence of integers from -5 to 5, then sum these absolute values up, and then take the log of this sum.

```{r,  echo=TRUE}
x <- seq(from = -5, to = 5, by = 1)
```

Given what we have learned so far, we would do the following.

```{r, echo=TRUE}
log(sum(abs(x))) # ugly looking
```

###

However, these nested function calls are not a natural way to think about the operations, and the syntax can become messy when there are many operations.

The pipe operator allows us to chain these operations together in a logical fashion. It "pipes" what is on the left-hand side of the `%>%` operator into the first argument of the function on the right-hand side.

```{r, echo=TRUE}
x %>% # better looking
  abs() %>% 
  sum() %>% 
  log() 
```

### Interpreting the pipe

> “Whenever you see the pipe `%>%`, think of the word 'then'...”
>
> Wright, Ellis, Hicks and Peng (2021)

For example, we should read the previous piece of code as:

```{r,  eval=FALSE, echo=TRUE}
x %>% # get x then
  abs() %>% # take the absolute values then
  sum() %>% # sum them up then
  log() # take the log
```

###

:::: {.exercise-box }
#### Exercise

In statistics and machine learning, the mean-absolute error (MAE) is a measure of the difference between values predicted by a model and observed values in the data. 

Given a vector of errors (typically known as residuals or prediction errors), the MAE is calculated by:

1. Taking the absolute values of the errors

2. Taking the average of the absolute values

Combine the `%>%` operator with the `mean()` and `sqrt()` and `round()` functions to calculate the MAE from the following vectors of observations and predictions, rounded to the nearest whole number.

The answer should be 8.

```{r rmse, exercise = TRUE, exercise.lines = 10}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)
```

```{r rmse-solution}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)

(observations - predictions) %>% # get errors, then
  abs() %>% # take absolute values, then
  mean() %>% # take mean, then
  round() # round to the nearest whole number
```

::::

<!-- ### When **not** to use the pipe -->

<!-- The tidyverse functions are all designed to work consistently with the pipe operator, as they typically take data frames/ tibbles as their first argument, and return data frames/ tibbles. -->

<!-- However, we should avoid using the pipe when: -->

<!-- - You need to manipulate more than one object at a time. Reserve pipes for a sequence of steps applied to one primary data object. -->
<!-- - There are meaningful intermediate objects that could be given informative names. -->

## Basics of dplyr

### What is dplyr?

:::: {style="display: flex;"}

::: {}
<br>

> dplyr is a tidyverse package that implements a "grammar of data manipulation". It provides a consistent set of verbs that help you solve the most common data manipulation challenges.
> 

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/dplyr.png")
```
:::

::::


### The dplyr verbs

The vast majority of data manipulation tasks can be solved using just five dplyr functions. They are all named after a *verb* which describes the task.

- Pick observations (rows) based on their values (`filter()`).
- Reorder the rows (`arrange()`). 
- Pick variables (columns) based on their names (`select()`).
- Create new variables by transforming existing variables (`mutate()`).
- Collapse multiple values down to a single summary (`summarise()`).

:::: {.extrabox }
The `group_by()` function allows the above operations to be split by a particular categorical/grouping variable. 
::::

<!-- You will notice that in this section we deal with __tibbles__ instead of __data frames__. A tibble is just a data frame with a better display format. Also, tibbles and data frames can return different objects. For example, extracting column from a data frame (via `example_data_frame[, 1]`) return a vector of differing data types, for a tibble on the other, subsetting a tibble my its column will always return a tibble. This make tibbles behaviour when coding more robust.  -->

We will examine each function in the following sections.

### 

All dplyr functions work similarly: 

1.  The first argument is the tibble (or data frame).

1.  The subsequent arguments describe what to do with the tibble, using the variable names (without quotes). 

1.  The result is a new tibble (or data frame).


### Data set

<!-- ```{r setup2, message = FALSE} -->
<!-- library(nycflights13) -->
<!-- data("flights", package = "nycflights13") -->
<!-- library(tidyverse) -->
<!-- ``` -->

To explore the basic data manipulation verbs of dplyr, we'll use `nycflights13::flights`. This tibble contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013 (we'll use a sample of 5000 of them for efficiency). The data comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0). We have loaded the sample in the background so that you can access it with the `flights` command. You can access documentation with the `?nycflights13::flights` command or [at this link](https://www.rdocumentation.org/packages/nycflights13/versions/1.0.1/topics/flights).

:::: {.exercise-box }

#### Exercise

Use the `head()` or `str()` functions to explore `flights` dataset.

```{r dplyr-1, exercise=TRUE, exercise.lines = 5}
flights
```

```{r, dplyr-1-solution}
head(flights)
str(flights)
```

::::

:::: {.notesbox }
Note that the variables `year`, `month` and `day`, are all integers. 
::::

## Filter rows with filter()

###

> `filter()` is used to subset rows using column values. 

The first argument is the data, and subsequent arguments are logical statements (called conditions) about the columns, using just the column names (without quotation marks or `$` operators). To be retained, the row must produce a value of `TRUE` for all conditions.


### 

The general form is:

```{r, eval = FALSE, echo = TRUE}
filter(data, condition_1, condition_2, condition_3)
```

Or, using the pipe:

```{r, eval = FALSE, echo = TRUE}
data %>% filter(condition_1, condition_2, condition_3)
```

:::: {.notesbox }
**N.B.** When we are piping data into dplyr functions, we can omit the first argument as dplyr assumes this to be the piped quantity.
::::

###

For example, we can use `filter()` to select all flights on January 1st with:

```{r, echo = TRUE}
filter(flights, month == 1, day == 1)
```

<!-- ```{r, echo = TRUE} -->
<!-- flights %>% filter(month == 1, day == 1) -->
<!-- ``` -->

### 

This is equivalent to the base R notation of `month == 1 & day == 1`. If we wanted to redo the previous example using base `R` we would have to use the following, less readable section of code. 

```{r, echo = TRUE}
flights[flights$month == 1 & flights$day == 1, ]
```

:::: {.notesbox }
**Note:** In contrast to base R, the dplyr syntax allows us call columns by their name (without the `$` operator), and allows us to separate `&` statements with a comma.
::::

###

:::: {.exercise-box }
#### Exercise

Filter all flights which departed in November *or* December:

```{r filter-2, exercise=TRUE}

```

```{r filter-2-solution}
filter(flights, month == 11 | month == 12)
# or, with the pipe
flights %>% filter(month == 11 | month == 12)
```

::::

###

:::: {.tipsbox }

**Tip:** An alternative form for selecting the months November or December would be `month %in% c(11, 12)`. This is very useful for selecting multiple months such as `month %in% c(11, 12, 1)`, which is nicer than using the OR notation `month == 11 | month == 12 | month == 1`.

```{r echo = TRUE, eval = FALSE}
filter(flights, month %in% c(12, 11, 1))
```

:::: 



## Arrange rows with arrange()

###

> `arrange()` orders the rows of a data frame by the values of selected columns.

### 

For example, to order the `flights` dataset by `year`, `month` and `day`:

```{r, echo = TRUE}
arrange(flights, year, month, day)
```

### 

By default, `arrange()` sorts in ascending order, but descending order can be achieved using `desc()`, for example:

```{r, echo = TRUE}
flights %>% arrange(desc(dep_delay))
```

### 

:::: {.exercise-box }
#### Exercise

The `distance` column of the `flights` dataset contains the distance between airports, in miles. Arrange the rows of the dataset based on the distance of the flights, from longest to shortest.

```{r, arrange-1, exercise = TRUE, exercise.lines = 6}

```

```{r, arrange-1-solution}
flights %>% arrange(desc(distance))
```
::::

## Select columns with select()

###

> `select()` allows you to select variables in your dataset to be retained or removed.

It is very useful for very large datasets which may contain many unnecessary variables.

###

For example if we wanted to select only the variables `year`, `month`, and `day`. 

```{r, echo = TRUE}
# Select columns by name
flights %>% select(year, month, day)
```

###

:::: {.exercise-box }

#### Exercise

Select only the `origin`, `dest` and `air_time` columns from the `flights` dataset. Store the result, and print the first few rows using `head()`.

```{r select-ex, exercise = TRUE, exercise.lines = 5}

```

```{r select-ex-solution}
flights_subset <- flights %>% select(origin, dest, air_time)
head(flights_subset)
```

::::

### Short cuts with select

There are several short cuts available for subsetting - they provide quick ways to specify a subset of columns. For example, You can use `:` to select all columns that are between two columns.

```{r select-2, echo = TRUE}
# Select all columns between year and day (inclusive)
flights %>% select(year:day)
```

###

Prefixing any (set of) column name(s) with a `-` or `!` removes them. 

```{r select-3, echo = TRUE}
# Select all columns except those from year to day (inclusive)
flights %>% select(-(year:day))
```

###

If you want to reorder columns, using `select()` with the `everything()` function is useful.

```{r select-4, echo = TRUE}
# Select time_hour, air_time and then every other column:
flights %>% select(time_hour, air_time, everything()) 
```

###

:::: {.exercise-box }
####  Exercise

Use the `select()` function to select all columns except those from `dep_time` to `tailnum` (inclusive), and re-order the resulting columns to start with `origin` and `dest`.

:::: {.hintsbox }
**Hint:** Use the pipe operator to apply the select function twice.
::::

```{r selectx2, exercise = TRUE, exercise.lines = 6}

```

```{r, selectx2-solution}
flights %>%
  select(-(dep_time:tailnum)) %>% # drop dep_time to tailnum (inclusive), then
  select(origin, dest, everything()) # re-order cols: origin, dest, and every other column
```

::::

###

:::: {.readingbox }
There are several other helper functions for subsetting columns with `select()`:

- `starts_with()` 
- `ends_with()`
- `contains()`
- `matches()`
- `num_range()`
- `one_of()`
- `everything()`
- `group_cols()`

Read [this documentation](https://dplyr.tidyverse.org/reference/select.html) on the dplyr website to learn more.
::::

## Add new variables with mutate()

###

> `mutate()` adds new variables that are functions of existing variables

It is often useful to create new variables which are transformations of one or more existing variables.

###

For example, the `air_time` variable is measured in minutes, and we might wish to have it in hours.

```{r, echo = TRUE}
flights %>%
  mutate(air_time_hr = air_time / 60) %>% # divide air_time by 60 to give in hours
  select(air_time, air_time_hr, everything()) # re-order columns to see air time columns first
```

###

We can create multiple new variables in a single `mutate()` call by separating them with a comma. Newly created variables are available immediately in the same `mutate()` call.

```{r, echo = TRUE}
flights %>% mutate(air_time_hr = air_time / 60, # what was the air time in hours? 
       gain = dep_delay - arr_delay, # add variable for how late the flight was
       gain_per_hour = gain / air_time_hr)
```

###

:::: {.exercise-box }
#### Exercise

Create a new variable, called `route`, which combines the `origin` and `dest` variables, separated by an underscore (`_`). 

:::: {.hintsbox }
**Hint:** The `paste()` function can be used to combine two strings. The `sep =` argument can be used to specify the string to separate them.
::::

```{r routemutate, exercise = TRUE, exercise.lines = 8}

```

```{r routemutate-solution}
flights %>%
  mutate(route = paste(origin, dest, sep = "_")) %>%
  select(route, everything()) # re-order columns to see route first
```

::::



###

:::: {.exercise-box }
#### Exercise

Create a new variable, called `av_speed`, which gives the average speed of the flight in miles per hour.  Re-order the rows from fastest to slowest.

:::: {.hintsbox }
**Hint:** First create an `air_time_hr` variable giving air time in hours, and then combine this with `distance` to get the average speed in miles per hour.
::::

```{r speed-mutate, exercise = TRUE, exercise.lines = 8}

```

```{r speed-mutate-solution}
flights %>%
  mutate(air_time_hr = air_time / 60, # first calculate air time in hours
         av_speed = distance / air_time_hr) %>% # average speed = distance / time
  arrange(desc(av_speed)) %>% # arrange by average speed (descending = fastest first)
  select(av_speed, everything()) # re-order columns to see av_speed first
```
::::


## Create summaries with summarise()

###

> `summarise()` reduces multiple values down to a single summary.

### 
The`summarise()` function  collapses a tibble or data frame to a single row:

```{r summarise-1, echo = TRUE}
summarise(flights, mean_dep_delay = mean(dep_delay, na.rm = TRUE))
```


After the data, each argument passed to `summarise()` is a summary statistic of one or more existing variables. The summary can be named (e.g., `mean_dep_delay =`) and multiple summaries can be separated by a comma.

###

:::: {.exercise-box }
#### Exercise

Calculate the minimum, maximum and median of the `dep_delay` variable.

```{r summary-delay, exercise = TRUE, exercise.lines = 8}

```

```{r summary-delay-solution}
flights %>% summarise(min_dep_delay = min(dep_delay, na.rm = TRUE),
                      max_dep_delay = max(dep_delay, na.rm = TRUE),
                      med_dep_delay = median(dep_delay, na.rm = TRUE))
```

::::

###  Grouped summaries using group_by()

On its own, `summarise()` may not provide much information. Often it is combined with `group_by()`.

The `group_by()` function changes the _scope_ of the tibble (or data frame) so instead of applying `summarise()` to the whole tibble (or data frame), it calculates the summaries separately for each of the unique groups created by `group_by()`. 

###

For example, if we wanted to generate a table of the `mean` and `median` delay time for every month, we would do the following:

```{r summarise-3, echo = TRUE}
flights %>% 
  group_by(year, month) %>% 
  summarise(
    median_delay = median(dep_delay, na.rm = TRUE),
    mean_delay = mean(dep_delay, na.rm = TRUE)
  )
```

###

:::: {.exercise-box }
#### Exercise

Calculate the mean and median `air_time` for each route (combination of `origin` and `dest`).

```{r summary-route, exercise = TRUE, exercise.lines = 8}

```

```{r summary-route-solution}
flights %>%
  group_by(origin, dest) %>% # group by route
  summarise(mean_air_time = mean(air_time, na.rm = TRUE),
            median_air_time = median(air_time, na.rm = TRUE))
```

::::

###

:::: {.readingbox }
**Note:** When we group by multiple variables and then use `summarise()`, the resulting tibble (or data frame) is grouped by one less variable... each summary "peels off" one level of the grouping. See the example in [R for Data Science](https://r4ds.had.co.nz/transform.html?q=ungroup#grouping-by-multiple-variables).
:::: 

:::: {.readingbox }
**Note:** If you need to return to performing operations on ungrouped data, use `ungroup()`. See the example in [R for Data Science](https://r4ds.had.co.nz/transform.html?q=ungroup#ungrouping).
:::: 

<!-- Together `group_by()` and `summarise()` provide a very quick way to produce summary tables. The returned tibble still has its _scope_ limited to the grouping variables. This can often cause a problem later on in the analysis if you want manipulation to be performed on the whole tibble. The `ungroup()` function returns the _scope_ to the full tibble. For example, we can scale the `mean_delay` from the previous code example using by max mean_deplay before and after using the `ungroup` function to change the scope back to the full dataset. -->

<!-- ```{r summarise-4, exercise = TRUE} -->
<!-- flights %>%  -->
<!--   group_by(year, month, day) %>%  -->
<!--   summarise( -->
<!--     mean_delay = mean(dep_delay, na.rm = TRUE) -->
<!--     ) %>%  -->
<!--   # max mean_delay is applied to the scope of the grouping varaibles -->
<!--   mutate(scaled_mean_delay_1 = mean_delay/max(mean_delay)) %>%  -->
<!--   ungroup() %>%  -->
<!--   # max mean_delay is applied to over the full dataset -->
<!--   mutate(scaled_mean_delay_2 = mean_delay/max(mean_delay)) -->
<!-- ``` -->

## Basics of ggplot2

###

:::: {style="display: flex;"}

::: {}
<br>

> ggplot2 is a system for declaratively creating graphics, based on The Grammar of Graphics.
> 

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/ggplot2.png")
```
:::

::::

###

The base R plotting system that we learned in the first tutorial is quick and easy but offers limited flexibility. In contrast, the `ggplot2` package provides a suite of functions that allow for elegant and detailed statistical graphics to be built *iteratively*, using a "layered approach". Rather than just a series of R commands, `ggplot2` implements a "graphical language".

### The mpg dataset

Let's use our first `ggplot2` graph to answer a question: *Do cars with big engines use more fuel than cars with small engines?* You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

`mpg` contains observations collected by the US Environmental Protection Agency on 234 different cars

```{r plotting-1, echo = TRUE}
mpg <- mpg %>% as_tibble() # the mpg dataset is a data frame. We convert it to a tibble.

mpg %>% head(3)
```

###

Among the variables in `mpg` are:

1. `displ`, a car's engine size, in litres.

1. `hwy`, a car's fuel efficiency on the highway, in miles per gallon (mpg). 
  A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. 

:::: {.extrabox }
To learn more about the `mpg` datset, open its help page by running `?mpg`.
::::

### Creating your first ggplot

The following code creates a scatter plot of `displ` on the x-axis and `hwy` on the y-axis:

```{r plotting-2, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

We will go through this piece of code in detail.

### The `ggplot()` command

- `ggplot()` creates a coordinate system to which you can add layers.

- The first argument of `ggplot()` is the dataset to be used in the visualization, i.e., `data = mpg`. Other datasets can be specified in subsequent layers, but this is the dataset that will be used "by default" .

- So `ggplot(data = mpg)` creates an empty figure - think of it as a "blank canvas", to which we will add layers.


### Aesthetics

The `mapping = aes(x = displ, y = hwy)` argument specifies default mappings from _**columns**_ in our data (`displ`, `hwy`), to _**aesthetics**_, which are visual properties of our plot. Here the aesthetics are what goes on the x and y-axes, but they could also be a mapping from a column in our data to e.g., colour, or shape. The aesthetics mappings specified within the  `ggplot()` command will be used by default in each of the layers we add.

:::: {.notesbox }
**Note:** We always refer to columns in our data within `aes()` by just their names - we don't need the `$` operator or quotation marks.
::::

### Geometric objects

The `+` operator allows us to *add* a layer to the existing plot. Each layer typically consists of a _**"geom"**_, which is short for _**geometric object**_.

- `geom_point()` adds a layer of points to your plot, for a scatter plot.

- `ggplot2` comes with many `geom_` functions that each add a different type of object to a plot. 

- If we were to draw lines instead of points, we would get a line plot (`geom_line()`). If we used bars, we would get a bar plot (`geom_bar()`.

- The geoms inherit the default aesthetics mappings we have specified earlier. So, the $x$ position of points is given by the `displ` value, and the $y$ position by the `hwy` value.

###

For our example, it makes sense to add a smooth trendline to the plot, with `geom_smooth()`.

```{r plotting-3, echo = TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_smooth()
```

> The plot shows a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`).

###

<!-- - Each geom function in ggplot2 takes a `mapping` argument. -->
<!-- - This defines how variables in your dataset are mapped to visual properties. -->
<!-- - The `mapping` argument is always paired with `aes()`, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes. -->


<!-- - ggplot2 looks for the mapped variables in the `data` argument, in this case, `mpg`. -->

<!-- Add a layer of points over the previous: -->

<!-- ```{r, eval=TRUE, echo=FALSE,  fig.height = 3, fig.width = 4.5, fig.align = "center"} -->
<!-- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + -->
<!--   geom_point() +  -->
<!--   geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), colour = "red", size = 2.2) -->
<!-- ``` -->


:::: {.exercise-box}

#### Exercise

Modify the following code so that the colour of the points depends on the type of car (`class` column), and the shape of the points depends on the the fuel type (`fl` column).

:::: {.hintsbox}
**Hint:** Add a mapping from the `class` and `fl` columns of the data to the `colour` and `shape` aesthetics.
::::

```{r plotting-4, exercise=TRUE, exercise.eval = TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```


```{r plotting-4-solution}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = class, shape = fl)) +
  geom_point()
```

::::


### Decorating your ggplot

`ggplot2` provides many functions for customising plots. Again, they are added to an existing plot using the `+` operator. We often want to add custom labels (using `labs()`, or separately using `xlab()`, `ylab()` and `ggtitle()`), and change the theme from the grey default.

:::: {.readingbox}
A list of themes can be found [here](https://ggplot2.tidyverse.org/reference/ggtheme.html)
::::

```{r decorate, echo = TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_smooth() +
  labs(x = "Engine displacement (litres)", # add labels
       y = "Highway miles per gallon",
       title = "Fuel economy data",
       subtitle = "Negative relationship between engine size and fuel efficiency") +
  theme_bw() # change theme
```

<!-- What if we wanted to see different classes of cars? We can use the `aes()` function to map the type of cars to different colours. Additionally, we can add a layer to highlight values outside the general trend. -->

<!-- ```{r plotting-4, exercise=TRUE} -->
<!-- p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) + -->
<!--   geom_point() -->

<!-- ``` -->

<!-- ```{r plotting-4-solution} -->
<!-- p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) + -->
<!--   geom_point() -->

<!-- p +  -->
<!--   geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20),  -->
<!--              colour = "black", size = 4, shape = 1) -->

<!-- ``` -->

<!-- What if we want to see the different classes of cars?  -->

<!-- ```{r plotting-5, exercise=TRUE} -->
<!-- ggplot(data = mpg) +  -->
<!--   geom_point(mapping = aes(x = displ, y = hwy, color = class)) -->
<!-- ``` -->

<!-- ### -->

<!-- What about the distributions? Its easy to plot distributions using the correct `geom_` argument: -->

<!-- - `geom_histogram`  -->
<!-- - `geom_boxplot`  -->

<!-- ```{r plotting-6, exercise=TRUE} -->
<!-- ggplot(data = mpg) +  -->
<!--   geom_histogram(mapping = aes(x = hwy)) -->
<!-- ``` -->

<!-- ```{r plotting-7, exercise=TRUE} -->
<!-- ggplot(data = mpg) +  -->
<!--   geom_boxplot(mapping = aes(x = class, y = hwy, fill = class)) +  -->
<!--   theme(axis.text.x = element_text(angle = 90)) -->
<!-- ``` -->

<!-- If you want to get fancy you can even layer different distributional visualizations.  -->

<!-- ```{r plotting-8, exercise=TRUE} -->
<!-- ggplot(data = mpg) +  -->
<!--   geom_violin(aes(x = class, y = hwy), fill = 'steelblue') +  -->
<!--   geom_boxplot(aes(x = class, y = hwy, fill = class), width = 0.1) +  -->
<!--   theme(axis.text.x = element_text(angle = 90)) -->
<!-- ``` -->


###

:::: {.exercise-box}

#### Exercise

Recreate the following plot:

```{r plotrecreate, echo = FALSE}
ggplot(data = mpg, mapping = aes(x = class, y = hwy, fill = class)) +
  geom_boxplot() +
  labs(x = "Car Type (`class`)",
       y = "Fuel Efficiency (`hwy`)",
       title = "Distribution of Fuel Efficieny by Class") +
  theme_light()
```

:::: {.hintsbox}
**Hint 1:** Use the `geom_boxplot()` geom.
::::

:::: {.hintsbox}
**Hint 2:** Use the `fill =` aesthetic, rather than `colour =`, to fill the boxplot with colour.
::::

```{r create-boxplot, exercise = TRUE, exercise.lines = 10}

```

```{r create-boxplot-solution}
ggplot(data = mpg, mapping = aes(x = class, y = hwy, fill = class)) +
  geom_boxplot() +
  labs(x = "Car Type (`class`)",
       y = "Fuel Efficiency (`hwy`)",
       title = "Distribution of Fuel Efficiency by Car Type") +
  theme_light()
```

::::

###

:::: {.exercise-box }

#### Exercise

The following plot was created from the `economics` dataset.

```{r, echo = FALSE}
ggplot(data = economics, mapping = aes(x = date, y = unemploy, colour = pop)) +
  geom_line()
```

Answer the following quiz questions about the plot. You can use the exercise box below to look at the `economics` dataset, or even try to recreate the plot yourself!

```{r test-quiz, exercise = TRUE, exercise.lines = 5}
head(economics)
```

```{r test-quiz-solution}
ggplot(data = economics, mapping = aes(x = date, y = unemploy, colour = pop)) +
  geom_line()
```

```{r ggplot-quiz}
quiz(caption = "",
  question("Which of the following `geom`s was used for creating the plot?",
    answer("`geom_point()`"),
    answer("`geom_line()`", correct = TRUE),
    answer("`geom_bar()`"),
    allow_retry = TRUE,
    correct = "Correct! We use the `geom_line()` function to connect observations and add lines to a plot.",
    incorrect = "Incorrect, look at the Geoms section of the [ggplot2 documentation](https://ggplot2.tidyverse.org/reference/) and try again."
  ),
  question("Q2: What columns in the data were mapped to the `x`, `y` and `colour` aesthetics?",
    answer("`x = date, y = unemploy, colour = pop`", correct = TRUE),
    answer("`x = date, y = pop, colour = unemploy`"),
    answer("`x = date, y = psavert, colour = unemploy`"),
    allow_retry = TRUE,
    correct = "Correct! The `date` variable is mapped to the x-axis, the `unemploy` variable to the y-axis and the line is coloured according to `pop`.",
    incorrect = "Incorrect! Look at the x and y-axis labels, and the colour legend for guidance."
  ))
```


::::

## Reading in data with and readr

###

:::: {style="display: flex;"}

::: {}
<br>

> The goal of `readr` is to provide a fast and friendly way to read rectangular data. Most of readr’s functions are concerned with turning flat files into data frames.

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/readr.png")
```
:::

::::

###

- We have learned some of the basics of manipulating and visualizing data using in-built R datasets.

- Often, you will need to read in data that you have acquired or gathered, from a text file where values are separated by some character. The most common format is comma-separated value (.csv). files. 

- The `readr` package is designed to make this task quick and efficient, and it interacts consistently with the other tidyverse packages.

- This section gives a short overview of how to load in your own external datasets. 

### readr functions

The main `readr` functions are:

* `read_csv()` reads comma delimited files.
* `read_tsv()` reads tab delimited files.
* `read_delim()` reads in files with any delimiter.
* `read_table()` reads a common variation of fixed width files where columns are separated by white space.

### Comparison to base R functions

Why use `readr`'s `read_csv()` over the built-in `read.csv()`?

- Typically faster.
- Provides more information on the variables which have been read in.
- Returns a `tibble` instead of a `data.frame`.

### Example

If the file `"UCI_Credit_Card_2.csv"` is stored in a `"data"` folder in our working directory, then we can read it into our R environment, and store the resulting tibble in `credit_tbl` with the following code:

```{r, echo=TRUE}
credit_tbl <- read_csv(file = "data/UCI_Credit_Card_2.csv")
```

The `file =` argument is used to specify the *path* to the file (`"data/UCI_Credit_Card_2.csv)"`).
 
###

```{r,echo=TRUE, eval = TRUE}
head(credit_tbl, 3) # Look at first three rows
```

###

:::: {.exercise-box}

#### Exercise

The `file =` argument can point to a folder on your computer where data are stored, or to a url if the data are stored on the internet. 

A `.csv` version of the [Palmer Penguins dataset](https://allisonhorst.github.io/palmerpenguins/) is available at [https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv](https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv). 

Use `read_csv()` to read the dataset into R from the url. Call the resulting tibble `penguins_tbl`. Print the first few rows of the dataset.

```{r readflights, exercise = TRUE, exercise.lines = 6}

```


```{r readflights-solution}
penguins_tbl <- read_csv(file = "https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv")
head(penguins_tbl)
```

::::

###

:::: {.readingbox}

:::: {style="display: flex;"}

::: {}
<br>
The readxl package can be used to get data out of Excel and into R. You can read about it [here](https://readxl.tidyverse.org/index.html)

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/readxl.png")
```
:::

::::

::::

<!-- `read_csv` parameters: -->

<!-- ```{r, echo = TRUE, eval = TRUE} -->
<!-- parms <- read_csv %>% args() %>% as.list() %>% names() -->
<!-- knitr::kable(tibble(Parameters = parms[c(1,2,3,8,10)])) -->
<!-- ``` -->

<!-- - Remember R has extensive help on every function: -->
<!--   - Highlight the function and press `F1` -->
<!--   - Or run `?function_of_interest`. -->

<!-- ```{r reading-1, exercise=TRUE} -->
<!-- ?read_csv -->
<!-- ``` -->

## References

- Wickham, H. and Grolemund, G., 2016. *R for data science: import, tidy, transform, visualize, and model data.* " O'Reilly Media, Inc.".

- Peng, R.D., 2016. *R programming for data science.* Leanpub.

- Wright, C., Ellis, S.E., Hicks, S.C., and Peng, R.D., 2021. *Tidyverse Skills for Data Science in R.* Leanpub

- Wickham, H., Navarro, D. and Pedersen, T.L.,  *ggplot2: Elegant Graphics for Data Analysis.* [Online book](https://ggplot2-book.org/)

---

#### Credit for hex stickers used

All hex sticker icons are from https://github.com/rstudio/hex-stickers.

---

#### Credit for icons used


<div>The following icons were made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com:</a></div>

```{r, out.width='8%'}
knitr::include_graphics("images/notes.png")
knitr::include_graphics("images/open-book.png")
knitr::include_graphics("images/extra.png")
```


<!-- --- -->



<!-- <div>The following icon was made by <a href="https://www.flaticon.com/authors/good-ware" title="Good Ware">Good Ware</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com:</a></div> -->


<!-- ```{r, out.width='8%'} -->
<!-- knitr::include_graphics("images/lightbulb.png") -->
<!-- ``` -->

---

<div>The following icon was made by <a href="https://www.flaticon.com/authors/smashicons" title="Smashicons">Smashicons</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com:</a></div>

```{r, out.width='8%'}
knitr::include_graphics("images/whisper.png")
```






