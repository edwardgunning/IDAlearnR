---
title: "Introduction to the `tidyverse`"
output:
  learnr::tutorial:
          progressive: true
          allow_skip: true
          highlight: pygments
          ace_theme: textmate
runtime: shiny_prerendered
---


<!-- insert UL logo in top right corner -->
<div style="text-align: right"><img src="images/ul-logo.jpg" width="150" /></div>


<!-- include CSS within markdown document -->
<!-- not sure why linking to the CSS doesn't work-->
```{css, echo = F}
@import url(https://fonts.googleapis.com/css?family=Montserrat:300,300i&display=swap);
@import url(https://fonts.googleapis.com/css?family=Josefin+Sans&display=swap);
@import url(https://fonts.googleapis.com/css?family=Fira+Mono&display=swap);
@import url(https://fonts.googleapis.com/css?family=Intero&display=swap);
@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed&display=swap);

:root {
  /* Fonts */
  --text-font-family: 'Inter';
  --text-font-is-google: 1;
  --text-font-family-fallback: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial;
  --text-font-base: sans-serif;
  --header-font-family: 'Josefin Sans';
  --header-font-is-google: 1;
  --code-font-family: 'Fira Mono';
  --code-font-is-google: 1;
  --base-font-size: 15px;
  --text-font-size: 1rem;
  --code-font-size: 0.9rem;
  --code-inline-font-size: 0.9rem;
  --header-h1-font-size: 2.75rem;
  --header-h2-font-size: 2.25rem;
  --header-h3-font-size: 1.75rem;

  /* Colors */
  --text-color: #272822;
  --header-color: #005337;
  --background-color: #FFFFFF;
  --link-color: #0fb157;
  --text-bold-color: #0fb157;
  --code-highlight-color: rgba(255,255,0,0.5);
  --inverse-text-color: #FFFFFF;
  --inverse-background-color: #005337;
  --inverse-header-color: #FFFFFF;
  --title-slide-background-color: #1c5253;
  --title-slide-text-color: #FFFFFF;
  --header-background-color: #1c5253;
  --header-background-text-color: #FFFFFF;
  --base: #1c5253;
  --white: #FFFFFF;
  --black: #272822;
}



code {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

code.r {
  font-family: Consolas, Monaco, 'Courier New', monospace;
  font-size: 14px;
}

pre {
  font-size: 14px;
}

h1, #TOC>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
  text-align: center;
}

h2, #TOC>ul>ul>li {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h3 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

h4 {
  color: #005337;
  font-family:  'Roboto Condensed';
  font-weight: bold;
}

a {
  color: #0ead5b;
}


body {
  font-family: var(--text-font-family), var(--text-font-family-fallback), var(--text-font-base);
  font-weight: 500;
  color: var(--text-color);
  font-size: 16px
}


a, a > code {
  color: #272822;
  text-decoration: underline;
  font-size: 16px;
}


.notesbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/notes.png)
}

.tipsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #fffbe6 5px center/3em no-repeat;
  background-image: url(images/lightbulb.png)
}

.readingbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/open-book.png)
}

.videobox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px dotted orange;
  border-radius: 10px;
  background: #FFEFD5 5px center/3em no-repeat;
  background-image: url(images/video.png)
}

.hintsbox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #B0C4DE;
  border-radius: 10px;
  background: #F0F8FF 5px center/3em no-repeat;
  background-image: url(images/whisper.png)
}

.extrabox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid #D8BFD8;
  border-radius: 10px;
  background: #FFF0F5 5px center/3em no-repeat;
  background-image: url(images/extra.png)
}


.exercise-box {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px double #E8E8E8;
  border-radius: 10px;
  background: #F8F8FF 5px center/3em no-repeat;
}


.center {
  text-align: center;
}
```


<!-- Got below tip for editor font size from https://github.com/rstudio/learnr/issues/197-->

```{js, echo = FALSE}
$(function() {
   var editor;
   $('.ace_editor').each(function( index ) {
     editor = ace.edit(this);
     editor.setFontSize("14px");
   });
})
```

<!-- <head> -->
<!-- <link rel="stylesheet" type="text/css" href="css/minty_bootstrap.css"> -->
<!-- </head> -->


```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)

credit_df <- read_csv('./data/UCI_Credit_Card_2.csv', n_max = 10)
flights <- read_csv('./data/flights.csv')

p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()
```

##

> “The Tidyverse has revolutionized the way in which data scientists do almost every aspect of their job.”
>
> Wright, Ellis, Hicks and Peng (2021)

## What is the tidyverse?

### 

- The [`tidyverse`](https://www.tidyverse.org/) is a coherent suite of R packages designed for *data import*, *manipulation*, *exploration* and *visualisation*.

- The tidyverse is a “package of packages” - when we load the tidyverse package, we load ("attach") multiple packages:

```{r, eval=FALSE, echo=TRUE}
> library(tidyverse)
-- Attaching packages --------------------------------------- tidyverse 1.2.1 --
v ggplot2 3.2.1     v purrr   0.3.2
v tibble  2.1.3     v dplyr   0.8.3
v tidyr   0.8.3     v stringr 1.4.0
v readr   1.3.1     v forcats 0.4.0
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x dplyr::filter() masks stats::filter()
x dplyr::lag()    masks stats::lag()
```

- All packages share an underlying design philosophy, grammar, and data structures… they are designed to work with **"tidy data"**.

### Tidy data

> “Tidy datasets are easy to manipulate, model and visualise, and have a specific structure:
each variable is a column, each observation is a row, and each type of observational unit
is a table.”
>
> Wickham (2014)

In short, tidy data are rectangular data, obeying the following interrelated rules (Fig. 1):

1.	Each variable must have its own column.

2.	Each observation must have its own row.

3.	Each value must have its own cell.

---

```{r, fig.cap="**Fig 1:** Graphical illustration of tidy data, taken from [R for Data Science](https://r4ds.had.co.nz/tidy-data.html?q=tidy%20data#non-tidy-data)", out.width='90%'}
knitr::include_graphics(path = "images/tidy-data-pic.png")
```

---

### tibbles

Tidy data provides an _consistent_ underlying data structure on which the tidyverse tools are built. You will also notice that, by default, the tidyverse uses __tibbles__, rather than __data frames__.

Tibbles are essentially data frames (as covered in the previous sections) but with some minor changes designed to improve functionality. 

Tibbles have slight modifications to help avoid programming errors, and have an enhanced method for bring printed to the screen.

:::: {.exercise-box }

#### Exercise

Create a tibble containing the variables `x = c("a", "b", "c")` and `y = c(1, 2, 3)` using the `tibble()` function. Print it to the screen.

:::: {.hintsbox }
**Hint:** Use the `tibble()` function in the exact same way you have used the `data.frame()` function in previous sections.
::::

```{r tibbledf, exercise = TRUE, exercise.lines = 7}

```

```{r tibbledf-solution}
tbl <- tibble(x = c("a", "b", "c"),
                 y = c(1, 2, 3))

tbl
```

::::

:::: {.readingbox }
The best place to read more about tibbles is [Chapter 10 of R for Data Science](https://r4ds.had.co.nz/tibbles.html#tibbles).
::::

From now on, we will use tibbles and data frames interchangeably.

<!-- ### Other useful packages -->

<!-- The following are some useful packages that are, at the time of writing, not included in the `tidyverse` but are very useful. -->

<!-- - `dbplyr`: for use with databases. -->
<!-- - `multiplyr`: for parallel processing. -->
<!-- - `plyr`: old package but has some handy functions in it. -->
<!-- - `tsibble`: makes dealing with and modeling timeseries data easier.  -->

## The pipe operator

###

The pipe operator is a powerful tool for clearly expressing a sequence of multiple R function operations.

Say we wish to first take the absolute value of the the sequence of integers from -5 to 5, then sum these absolute values up, and then take the log of this sum.

```{r,  echo=TRUE}
x <- seq(from = -5, to = 5, by = 1)
```

Given what we have learned so far, we would do the following.

```{r, echo=TRUE}
log(sum(abs(x))) # ugly looking
```

###

However, these nested function calls are not a natural way to think about the operations, and the syntax can become messy when there are many operations.

The pipe operator allows us to chain these operations together in a logical fashion. It "pipes" what is on the left-hand side of the `%>%` operator into the first argument of the function on the right-hand side.

```{r, echo=TRUE}
x %>% # better looking
  abs() %>% 
  sum() %>% 
  log() 
```

### Interpreting the pipe

> “Whenever you see the pipe `%>%`, think of the word 'then'...”
>
> Wright, Ellis, Hicks and Peng (2021)

For example, we should read the previous piece of code as:

```{r,  eval=FALSE, echo=TRUE}
x %>% # get x then
  abs() %>% # take the absolute values then
  sum() %>% # sum them up then
  log() # take the log
```


:::: {.exercise-box }
### Exercise

In statistics and machine learning, the mean-absolute error (MAE) is a measure of the difference between values predicted by a model and observed values in the data. 

Given a vector of errors (typically known as residuals or prediction errors), the MAE is calculated by:

1. Taking the absolute values of the errors

2. Taking the average of the absolute values

Combine the `%>%` operator with the `mean()` and `sqrt()` and `round()` functions to calculate the RMSE from the following vectors of observations and predictions, rounded to the nearest whole number.

The answer should be 8.

```{r rmse, exercise = TRUE, exercise.lines = 10}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)
```

```{r rmse-solution}
observations <- c(86.93, 15.36, -6.46, -5.47, 4.71, -2.95, -14.41, 0.44, 27.18, 
112.69)
predictions <- c(100, 16.21, 4.14, 1.67, 1.06, 1.06, 1.67, 4.14, 16.21, 100)

(observations - predictions) %>% # get errors, then
  abs() %>% # take absolute values, then
  mean() %>% # take mean, then
  round() # round to the nearest whole number
```

::::

### When **not** to use the pipe

The tidyverse functions are all designed to work consistently with the pipe operator, as they typically take data frames/ tibbles as their first argument, and return data frames/ tibbles.

However, we should avoid using the pipe when:

- You need to manipulate more than one object at a time. Reserve pipes for a sequence of steps applied to one primary data object.
- There are meaningful intermediate objects that could be given informative names.

## Basics of dplyr

### What is dplyr?

:::: {style="display: flex;"}

::: {}
<br>

> dplyr is a tidyverse package that implements a "grammar of data manipulation". It provides a consistent set of verbs that help you solve the most common data manipulation challenges.
> 

:::

::: {}
```{r, echo = FALSE, fig.width=3, fig.height=3, out.width = '125px'}
knitr::include_graphics("images/dplyr.png")
```
:::

::::


### The dplyr verbs

The vast majority of data manipulation tasks can be solved using just five dplyr functions. They are all named after a *verb* which describes the task.

- Pick observations by their values (`filter()`).
- Reorder the rows (`arrange()`). 
- Pick variables by their names (`select()`).
- Create new variables by transforming existing variables (`mutate()`).
- Collapse many values down to a single summary (`summarise()`).

:::: {.extrabox }
The `group_by()` function allows the above operations to be split by a particular categorical/grouping variable. 
::::
<!-- You will notice that in this section we deal with __tibbles__ instead of __data frames__. A tibble is just a data frame with a better display format. Also, tibbles and data frames can return different objects. For example, extracting column from a data frame (via `example_data_frame[, 1]`) return a vector of differing data types, for a tibble on the other, subsetting a tibble my its column will always return a tibble. This make tibbles behaviour when coding more robust.  -->

We will examine each function in the following sections.

### 

All dplyr functions work similarly: 

1.  The first argument is the tibble.
1.  The subsequent arguments describe what to do with the tibble, using the variable names (without quotes). 
1.  The result is a new tibble.


### Data set

```{r setup2, message = FALSE}
library(nycflights13)
library(tidyverse)
```


To explore the basic data manipulation verbs of dplyr, we'll use `nycflights13::flights`. This tibble contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013. The data comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0), and is documented in `?flights`.

```{r dplyr-1, exercise=TRUE}
flights
```

Note that the variables, year, month and day, are all numeric. 

## Filter rows with `filter()`

Using `filter` to select all flights on January 1st with:

```{r filter-1, exercise=TRUE}
filter(flights, month == 1, day == 1)
flights %>% filter(month == 1, day == 1) # or using the pipe
```

Multiple logical `AND` arguments can be separated by a comma. This is equivalent to the base R notation of `month == 1 & day == 1`. Also of note, when we are piping data into dplyr functions, we can omit the first argument of `filter()`, as dplyr assumes this to be the piped quantity. If we wanted to redo the previous example using base `R` we would have to use the following, less readable section of code. 

```{r filter-1-1, exercise = TRUE}
flights[flights$month == 1 & flights$day == 1, ]
```

If you want to pull flights which departed in November or December:

```{r filter-2, exercise=TRUE}
filter(flights, month == 11 | month == 12)
```

An alternative form for selecting the months November or December would be `month %in% c(11,12)`. This is very useful for selecting multiple months such as `month %in% c(11,12,1)`, which is nicer than using the OR notation `month == 11 | month == 12 | month == 1`.

```{r filter-3, exercise=TRUE}
filter(flights, month %in% c(12, 11, 1))
```

## Arrange rows with `arrange()`

- `arrange()` changes the order of the rows in a dataset.
- additional columns can be used to break ties in the dataset

```{r filter-4, exercise=TRUE}
flights %>% arrange(year, month, day)
```

By default, `arrange()` sorts in ascending order, but descending order can be achieved using `desc()`.

```{r, filter-5, exercise=TRUE}
flights %>% arrange(desc(dep_delay))
```

## Select columns with `select()`

- `select()` allows you to select variables in your dataset to be retained or removed..
- useful for very large datasets which may contain many unnecessary variables.

For example if we wanted to select only the variables year, month, and day. 

```{r select-1, exercise=TRUE}
# Select columns by name
flights %>% select(year, month, day)
```

There are several short cuts available for subsetting. You can use `:` to select all variables that are between two variables.

```{r select-2, exercise=TRUE}
# Select all columns between year and day (inclusive)
flights %>% select(year:day)
```

Prefixing any varaible name with a `-` removes them from the tibble. 

```{r select-3, exercise=TRUE}
# Select all columns except those from year to day (inclusive)
flights %>% select(-(year:day))
```

- If you want to reorder some variables in the `tibble`, the function `everything()` is useful.

```{r select-4, exercise=TRUE}
select(flights, time_hour, air_time, everything()) 
```

There are several helper functions for subsetting varaibles:

- `starts_with()` 
- `ends_with()`
- `contains()`
- `matches()`
- `num_range()`
- `one_of()`
- `everything()`
- `group_cols()`

R has extensive documentation on how to use these functions.

## Add new variables with `mutate()`

It is often useful to create new variables which are transformations of existing variables.

```{r mutate-1, exercise=TRUE}
flights_sml <- select(flights, year:day, ends_with("delay"), 
                      distance, air_time)

mutate(flights_sml,
  gain = dep_delay - arr_delay, # add variable for how late the flight was
  hours = air_time / 60, # what was the air time in hours? 
  gain_per_hour = gain / hours 
)
```

Note that we can reference variables created earlier in the same `mutate` function call. 

## Summaries with `summarise()`

The function `summarise()` collapses a tibble to a single row:

```{r summarise-1, exercise=TRUE}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

On its own, `summarise()` may not provide much information. Often it is combined with `group_by()`.

```{r summarise-2, exercise=TRUE}
group_by(flights, year, month, day)
```

The `group_by()` function changes the _scope_ of the tibble so instead of applying `summarise()` to the whole tibble, it calculates the summaries using the unique groups created by `group_by()`. For example, if we wanted to generate a table of the `mean` and `median` delay time for every day in the tibble, we would do the following:

```{r summarise-3, exercise=TRUE}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(
    median_delay = median(dep_delay, na.rm = TRUE),
    mean_delay = mean(dep_delay, na.rm = TRUE)
    )
```

Together `group_by()` and `summarise()` provide a very quick way to produce summary tables. The returned tibble still has its _scope_ limited to the grouping variables. This can often cause a problem later on in the analysis if you want manipulation to be performed on the whole tibble. The `ungroup()` function returns the _scope_ to the full tibble. For example, we can scale the `mean_delay` from the previous code example using by max mean_deplay before and after using the `ungroup` function to change the scope back to the full dataset.

```{r summarise-4, exercise = TRUE}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(
    mean_delay = mean(dep_delay, na.rm = TRUE)
    ) %>% 
  # max mean_delay is applied to the scope of the grouping varaibles
  mutate(scaled_mean_delay_1 = mean_delay/max(mean_delay)) %>% 
  ungroup() %>% 
  # max mean_delay is applied to over the full dataset
  mutate(scaled_mean_delay_2 = mean_delay/max(mean_delay))
```

## Basics of `ggplot2`

The `ggplot2` provides a suite of plotting functions that allow for the creation of quick and clean visualizations from data. Let's use our first graph to answer a question: Do cars with big engines use more fuel than cars with small engines? You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

### `mpg` data set

`mpg` contains observations collected by the US Environmental Protection Agency on 234 different cars

```{r plotting-1, exercise=TRUE}
mpg <- mpg %>% as_tibble() # the mpg dataset is a data frame. To make use of tibble nice printing we convert it to a tibble.

mpg %>% head(3)
```

Among the variables in `mpg` are:

1. `displ`, a car's engine size, in litres.

1. `hwy`, a car's fuel efficiency on the highway, in miles per gallon (mpg). 
  A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. 

To learn more about `mpg`, open its help page by running `?mpg`.

### plotting

To plot `mpg`, run this code to put `displ` on the x-axis and `hwy` on the y-axis:

```{r plotting-2, exercise=TRUE}
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point()


p
```

- `ggplot()` creates a coordinate system to which you can add layers.
- The first argument of `ggplot()` is the dataset to be used in the visualization.
- So `ggplot(data = mpg)` creates an empty figure, which is not useful on its own, so I'm not going to show it here.
- `geom_point()` adds a layer of points to your plot. 
- ggplot2 comes with many `geom_` functions that each add a different type of layer to a plot.

You can save a graph object and add layers to it. For example, the code below adds a smoother to the scatter plot.

```{r plotting-3, exercise=TRUE}
p + geom_smooth()
```

- The plot shows a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`).

- Each geom function in ggplot2 takes a `mapping` argument.
- This defines how variables in your dataset are mapped to visual properties.
- The `mapping` argument is always paired with `aes()`, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes.
<!-- - ggplot2 looks for the mapped variables in the `data` argument, in this case, `mpg`. -->

<!-- Add a layer of points over the previous: -->

<!-- ```{r, eval=TRUE, echo=FALSE,  fig.height = 3, fig.width = 4.5, fig.align = "center"} -->
<!-- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + -->
<!--   geom_point() +  -->
<!--   geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), colour = "red", size = 2.2) -->
<!-- ``` -->

What if we wanted to see different classes of cars? We can use the `aes()` function to map the type of cars to different colors. Additionally, we can add a layer to highlight values outside the general trend.

```{r plotting-4, exercise=TRUE}
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point()

```

```{r plotting-4-solution}
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point()

p + 
  geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), 
             colour = "black", size = 4, shape = 1)

```

What if we want to see the different classes of cars? 

```{r plotting-5, exercise=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

What about the distributions? Its easy to plot distributions using the correct `geom_` argument:

- `geom_histogram` 
- `geom_boxplot` 

```{r plotting-6, exercise=TRUE}
ggplot(data = mpg) + 
  geom_histogram(mapping = aes(x = hwy))
```

```{r plotting-7, exercise=TRUE}
ggplot(data = mpg) + 
  geom_boxplot(mapping = aes(x = class, y = hwy, fill = class)) + 
  theme(axis.text.x = element_text(angle = 90))
```

If you want to get fancy you can even layer different distributional visualizations. 

```{r plotting-8, exercise=TRUE}
ggplot(data = mpg) + 
  geom_violin(aes(x = class, y = hwy), fill = 'steelblue') + 
  geom_boxplot(aes(x = class, y = hwy, fill = class), width = 0.1) + 
  theme(axis.text.x = element_text(angle = 90))
```

## Reading in data with `R` and `readr.`

We have learned some of the basics of manipulating and visualizing data using in-built R datasets. This section shows you how to load in your own external datasets.

### Getting started:
* `read_csv()` reads comma delimited files.
* `read_tsv()` reads tab delimited files.
* `read_delim()` reads in files with any delimiter.
* `read_table()` reads a common variation of fixed width files where columns are separated by white space.

Why use `readr`'s `read_csv()` over in-build `read.csv()`?

- Typically faster.
- Provides information on the variables which have been read in.
- Returns a `tibble` instead of a `data.frame`.

```{r, echo=TRUE, eval = FALSE}
credit_df <- read_csv(file = "./data/credit_data.csv")
```

- Tibbles provide extra information: 

```{r,echo=TRUE, eval = TRUE}
credit_df
```

<!-- `read_csv` parameters: -->

<!-- ```{r, echo = TRUE, eval = TRUE} -->
<!-- parms <- read_csv %>% args() %>% as.list() %>% names() -->
<!-- knitr::kable(tibble(Parameters = parms[c(1,2,3,8,10)])) -->
<!-- ``` -->

- Remember R has extensive help on every function:
  - Highlight the function and press `F1`
  - Or run `?function_of_interest`.

```{r reading-1, exercise=TRUE}
?read_csv
```
